(* ::Package:: *)

(* ::Input:: *)
(*(* =======================================*)(*Serpent S-box lookup table:S0..S7*)(* =======================================*)*)
(*ClearAll["Global"];*)
(**)
(*(*---S-box tables ---*)*)
(*SBoxes={{3,8,15,1,10,6,5,11,14,13,4,2,7,0,9,12},(*S0*)*)
(*{15,12,2,7,9,0,5,10,1,11,14,8,6,13,3,4},(*S1*)*)
(*{8,6,7,9,3,12,10,15,13,1,14,4,0,11,5,2},(*S2*)*)
(*{0,15,11,8,12,9,6,3,13,1,2,4,10,7,5,14},(*S3*)*)
(*{1,15,8,3,12,0,11,6,2,5,4,10,9,14,7,13},(*S4*)*)
(*{15,5,2,11,4,10,9,12,0,3,14,8,13,6,7,1},(*S5*)*)
(*{7,2,12,5,8,4,6,11,14,9,1,15,13,3,10,0},(*S6*)*)
(*{1,13,15,0,14,8,2,11,7,4,12,10,9,3,5,6}   (*S7*)};*)
(**)
(*ApplySbox[block_List,indicebox_]:=Module[{out=ConstantArray[0,4],nib,word,pos,sostit},*)
(*Do[word=block[[i]];*)
(*Do[pos=j*4;*)
(*nib=BitAnd[BitShiftRight[word,pos],15]; (* Shifta la parola per prendere il nibble giusto e portarlo in fondo, usiamo la maschera 1111 per avere solo i 4 bit che ci interessano.*)*)
(*sostit=SBoxes[[indicebox+1,nib+1]];*)
(*out[[i]]=BitOr[out[[i]],BitShiftLeft[sostit,pos]];*)
(*,{j,0,7}]*)
(*,{i,1,4}];out];*)
(**)
(**)


(* ::Input:: *)
(*(*rotazione sinistra bitwise su 32 bit*)*)
(*rotLeft32[x_,n_]:=Module[{mask=2^32-1},BitAnd[BitOr[BitShiftLeft[x,n],BitShiftRight[x,32-n]],mask]];*)
(*(*BitshiftLeft ma questa mantiene la dimensione di 32bit*)*)
(*bshiftleft32[x_,n_]:=BitAnd[BitShiftLeft[x,n],mask32];*)
(**)
(*LinearTransform[x0_,x1_,x2_,x3_]:=Module[{X0=x0,X1=x1,X2=x2,X3=x3},*)
(*X0=rotLeft32[X0,13];*)
(*X2=rotLeft32[X2,3];*)
(*X1=BitXor[X1,X0,X2];*)
(*X3=BitXor[X3,X2,bshiftleft32[X0,3]];*)
(*X1=rotLeft32[X1,1];*)
(*X3=rotLeft32[X3,7];*)
(*X0=BitXor[X0,X1,X3];*)
(*X2=BitXor[X2,X3,bshiftleft32[X1,7]];*)
(*X0=rotLeft32[X0,5];*)
(*X2=rotLeft32[X2,22];*)
(*{X0,X1,X2,X3}];*)
(**)
(*(*---Round ---*)*)
(**)
(*SerpentRound[block_List,roundIndex_Integer,keyRound_List]:=Module[{Y=ConstantArray[0,4],Y0,Y1,Y2,Y3,mod8},*)
(*(*Step 1:XOR con chiave round + applicazione sbox*)*)
(*Do[*)
(*Y[[i]]=BitXor[block[[i]],keyRound[[i]]],{i,1,4}];*)
(*mod8=Mod[roundIndex,8];*)
(*{Y0,Y1,Y2,Y3}=ApplySbox[Y,mod8];*)
(*(*Step 2: trasformazioni lineari se non \[EGrave] l'ultimo round*)*)
(*If[roundIndex<31,{Y0,Y1,Y2,Y3}=LinearTransform[Y0,Y1,Y2,Y3];];*)
(*{Y0,Y1,Y2,Y3}];*)


(* ::Input:: *)
(**)
(*SerpentFinalRound[block_List,keyRound_List,keyRound32_List]:=Module[{Y=block, Y0,Y1,Y2,Y3},*)
(*(*XOR con K31*)*)
(*Do[Y[[i]]=BitXor[block[[i]],keyRound[[i]]],{i,1,4}];*)
(*(*S7 fissa*)*)
(*{Y0,Y1,Y2,Y3}=ApplySbox[Y,7];*)
(*(*XOR con K32 finale*)*)
(*Y0=BitXor[Y0,keyRound32[[1]]];*)
(*Y1=BitXor[Y1,keyRound32[[2]]];*)
(*Y2=BitXor[Y2,keyRound32[[3]]];*)
(*Y3=BitXor[Y3,keyRound32[[4]]];*)
(*{Y0,Y1,Y2,Y3}];*)
(**)


(* ::Input:: *)
(*(*------------------------------------------------KEY SCHEDULE--------------------------------------------------------------*)*)
(**)


(* ::Input:: *)
(**)
(**)
(*(*32-bit mask and FRAC constant*)*)
(*mask32=2^32-1;*)
(*FRAC=16^^9E3779B9;  (*0x9E3779B9*)*)
(**)
(*Hextobytes[Key_]:= Module[{coppie},*)
(*If[OddQ[StringLength[Key]],Key="0"<>Key;];*)
(*(*Spezza in coppie di due caratteri (1 byte)*)*)
(*coppie=StringPartition[Key,2];*)
(*(*Converte ogni coppia esadecimale in intero 0..255*)*)
(*ToExpression["16^^"<>#]&/@coppie];*)
(**)
(*(*---Pad key bytes in un intero a 256-bit  e separo in  8 x 32-bit parole ---*)*)
(**)
(*PadKey[keyBytes_]:=Module[{len=Length[keyBytes],big,words},*)
(*(* Costruisco l'intero 256-bit dai byte,little-endian*)*)
(*big=Total[Mod[keyBytes,256]*BitShiftLeft[1,8*Range[0,len-1]]];*)
(*(* Padding Serpent:aggiungo un singolo bit'1' SOLO se len<32*)*)
(*If[len<32,big=BitOr[big,BitShiftLeft[1,8*len]]];*)
(*(* Estraggo 8 parole da 32 bit (little-endian)*)*)
(*words=BitAnd[BitShiftRight[big,32*Range[0,7]],mask32];*)
(*words];*)
(**)
(*(*---Genero prekeys w[0..131] ---*)*)
(*GeneratePrekeysW[initialWords_List]:=Module[{x,w,i},(*initialWords sono 8 parole date dalla chiave *)*)
(*x=Table[0,{i,0,140}];*)
(*(*metto le 8 parole iniziali  x[0..7]*)*)
(*Do[x[[i+1]]=BitAnd[initialWords[[i]],mask32],{i,1,8}];*)
(*Do[x[[i]]=rotLeft32[BitXor[x[[i-8]],x[[i-5]],x[[i-3]],x[[i-1]],FRAC,(i-9) ],11],{i,9,140}];*)
(*(*generate x[8]..x[139]: x[i]=ROTL(x[i-8]XOR x[i-5]XOR x[i-3]XOR x[i-1]XOR FRAC XOR(i-8),11) *)*)
(*w=Table[x[[i+8+1]],{i,0,131}];(*estraggo le 132 words *)*)
(*w];*)
(**)
(**)
(*(*---costruiamo le subkeys (33 subkeys di 4 words ciascuna) dalle prekeys w[0..131]---*)*)
(*GenerateRoundSubkeys[w_List]:=Module[{indices,pvalues,sboxIndices,blocks},(*0..32*)*)
(*indices=Range[0,32];*)
(*(*quale S-box usare*)*)
(*sboxIndices=Mod[35-indices,8];(*35-Range[0,32] per seguire la numerazione S3 S2 S1 S0 S7...*)*)
(*(*estrai i blocchi da 4 parole:{w[4i],w[4i+1],w[4i+2],w[4i+3]}*)*)
(*blocks=w[[4 #+{1,2,3,4}]]&/@indices;*)
(*(*applica la S-box in modo funzionale*)*)
(*MapThread[ApplySbox,{blocks,sboxIndices}]*)
(*];*)
(**)
(*SerpentKeySchedule[key_]:=Module[{subkeys},*)
(*subkeys=GenerateRoundSubkeys[GeneratePrekeysW[PadKey[Hextobytes[key]]]];*)
(*(*returns list of 33 elements each length 4*)subkeys];*)
(**)
(**)
(**)


(* ::Input:: *)
(*(*--------------------------------------- CYPHER ----------------------------------------------*)*)


(* ::Input:: *)
(*PKCS7Padding[data_List,blockSize_Integer]:=Module[{padSize},*)
(*padSize=blockSize-Mod[Length[data],blockSize];*)
(*Join[data,ConstantArray[padSize,padSize]]];*)
(**)
(**)
(*StringToSerpentBlocks[str_String]:=Module[{bytes,padded,blocks},(*converte UTF-8\[RightArrow]lista di byte*)*)
(*bytes=ToCharacterCode[str,"UTF-8"];*)
(*(*applica PKCS#7*)*)
(*padded=PKCS7Padding[bytes,16];*)
(*(*frammenta in blocchi da 16 byte*)*)
(*blocks=Partition[padded,16];*)
(*blocks];*)
(**)
(*(*perch\[EGrave] lavoriamo in 4 parole da 32 bit *)*)
(*Bytes16ToWords4[block_List]:=Module[{x0,x1,x2,x3},*)
(*x0=block[[1]]+BitShiftLeft[block[[2]],8]+BitShiftLeft[block[[3]],16]+BitShiftLeft[block[[4]],24];*)
(*x1=block[[5]]+BitShiftLeft[block[[6]],8]+BitShiftLeft[block[[7]],16]+BitShiftLeft[block[[8]],24];*)
(*x2=block[[9]]+BitShiftLeft[block[[10]],8]+BitShiftLeft[block[[11]],16]+BitShiftLeft[block[[12]],24];*)
(*x3=block[[13]]+BitShiftLeft[block[[14]],8]+BitShiftLeft[block[[15]],16]+BitShiftLeft[block[[16]],24];*)
(*{x0,x1,x2,x3}];*)
(**)
(*Words4ToBytes16[{x0_,x1_,x2_,x3_}]:=Flatten@Table[BitAnd[BitShiftRight[x0,8 i],255],{i,0,3}]~Join~Flatten@Table[BitAnd[BitShiftRight[x1,8 *i],255],{i,0,3}]~Join~Flatten@Table[BitAnd[BitShiftRight[x2,8 i],255],{i,0,3}]~Join~Flatten@Table[BitAnd[BitShiftRight[x3,8 *i],255],{i,0,3}];*)
(**)
(*SerpentEncryptBlockWords[subkeys_List,blockWords_List]:=Module[{rounds,final},*)
(*rounds=Table[With[{r=i},*)
(*Function[block,SerpentRound[block,r,subkeys[[r+1]]]]],*)
(*{i,0,30}];*)
(*final=With[{r=31},*)
(*Function[block,SerpentFinalRound[block,subkeys[[32]],subkeys[[33]]]]*)
(*];*)
(*Fold[#2[#1]&,blockWords,Join[rounds,{final}]]];*)
(**)
(*(* Full-string encryption (ECB) con padding PKCS#7   *)*)
(*SerpentEncryptCipher[keyHex_String,plaintext_String]:=Module[{roundkeys,blocksBytes,blocksWords,encryptedBlocks,hexBlocks},*)
(*roundkeys=SerpentKeySchedule[keyHex];*)
(*(* Padding del blocco plaintext PKCS#7*)*)
(*blocksBytes=StringToSerpentBlocks[plaintext];(*lista di 16-byte blocks*)blocksWords=Bytes16ToWords4/@blocksBytes;(*converti ogni block*)encryptedBlocks=SerpentEncryptBlockWords[roundkeys,#]&/@blocksWords;*)
(**)
(*hexBlocks=(StringJoin@IntegerString[#,16,2]&/@Flatten[Words4ToBytes16/@encryptedBlocks]);*)
(**)
(*StringJoin@hexBlocks*)
(*];*)
(**)
(**)
(**)


(* ::Input:: *)
(*key="00112233445566778899AABBCCDDEEFF";*)
(*pt="L allarme di Confetra: Le merci arrivano lo stesso via camion e noi perdiamo traffici. Il governo ha anticipato l\[CloseCurlyQuote]entrata in vigore rispetto all\[CloseCurlyQuote]Europa. Cos\[IGrave] i big del fast fashion spediscono in altri aeroporti comunitari";*)
(*ctHex=SerpentEncryptCipher[key,pt];*)
(*ctHex*)


(* ::Input:: *)
(*(*----------------------------------------------------------Decifratura------------------------------------------------------------------*)*)


(* ::Input:: *)
(*InvSBoxes:=Module[{s1},*)
(*s1=#+1;(*0..15\[RightArrow]1..16*)*)
(*InversePermutation[s1]-1     (*ritorno a 0..15*)*)
(*]&/@SBoxes;*)
(**)
(*ApplyInvSbox[block_List,indicebox_]:=Module[{out=ConstantArray[0,4],nib,word,pos,sostit},*)
(*Do[word=block[[i]];*)
(*Do[pos=j*4;*)
(*nib=BitAnd[BitShiftRight[word,pos],15];*)
(*sostit=InvSBoxes[[indicebox+1,nib+1]];*)
(*out[[i]]=BitOr[out[[i]],BitShiftLeft[sostit,pos]];*)
(*,{j,0,7}]*)
(*,{i,1,4}];*)
(*out];*)
(**)
(*rotRight32[x_,n_]:=rotLeft32[x,32-n];*)
(**)
(*InvLinearTransform[x0_,x1_,x2_,x3_]:=Module[{X0=x0,X1=x1,X2=x2,X3=x3},*)
(*X2=rotRight32[X2,22];*)
(*X0=rotRight32[X0,5];*)
(*X2=BitXor[X2,X3,bshiftleft32[X1,7]];*)
(*X0=BitXor[X0,X1,X3];*)
(*X3=rotRight32[X3,7];*)
(*X1=rotRight32[X1,1];*)
(*X3=BitXor[X3,X2,bshiftleft32[X0,3]];*)
(*X1=BitXor[X1,X0,X2];*)
(*X2=rotRight32[X2,3];*)
(*X0=rotRight32[X0,13];*)
(*{X0,X1,X2,X3}];*)
(**)
(**)
(**)
(*SerpentInvRound[block_List,r_Integer,keyRound_List]:=Module[{Y=block},*)
(*(*1. inversa LT *)Y=InvLinearTransform@@Y;*)
(*(*2. inversa S-box*)Y=ApplyInvSbox[Y,Mod[r,8]];*)
(*(*3. XOR con subkey*)MapThread[BitXor,{Y,keyRound}]]*)
(**)
(**)
(**)
(*SerpentInvFinalRound[block_List,keyRound31_List,keyRound32_List]:=Module[{Y},Y=MapThread[BitXor,{block,keyRound32}];*)
(*Y=ApplyInvSbox[Y,7];*)
(*Y=MapThread[BitXor,{Y,keyRound31}];*)
(*Y];*)
(*SerpentDecryptBlockWords[subkeys_List,blockWords_List]:=Module[{state},*)
(*state=SerpentInvFinalRound[blockWords,subkeys[[32]],subkeys[[33]]];*)
(*state=Fold[Function[{b,r},SerpentInvRound[b,r,subkeys[[r+1]]]],state,Reverse@Range[0,30]];*)
(*state];*)
(**)
(**)


(* ::Input:: *)
(*PKCS7Unpadding[data_List]:=Module[{pad},pad=Last[data];*)
(*If[pad<1||pad>16||Take[data,-pad]=!=ConstantArray[pad,pad],*)
(*(*padding NON valido*)data,*)
(*(*padding valido*)Take[data,Length[data]-pad]]];*)
(**)


(* ::Input:: *)
(*HexStringToBlocks[hex_String]:=Partition[ToExpression["16^^"<>#]&/@StringPartition[hex,2],16];*)
(**)
(**)
(*SerpentDecryptCipher[keyHex_String,ciphertextHex_String]:=Module[{roundkeys,blocksBytes,blocksWords,decryptedWords,decryptedBytes,unpadded},roundkeys=SerpentKeySchedule[keyHex];*)
(*blocksBytes=HexStringToBlocks[ciphertextHex];*)
(*blocksWords=Bytes16ToWords4/@blocksBytes;*)
(*decryptedWords=SerpentDecryptBlockWords[roundkeys,#]&/@blocksWords;*)
(*decryptedBytes=Flatten[Words4ToBytes16/@decryptedWords];*)
(*unpadded=PKCS7Unpadding[decryptedBytes];*)
(*FromCharacterCode[unpadded,"UTF-8"]];*)


(* ::Input:: *)
(*key="00112233445566778899AABBCCDDEEFF";*)
(*SerpentEncryptCipher[key,"hello world"]*)
(**)
(*SerpentDecryptCipher[key,SerpentEncryptCipher[key,"hello world"]]*)


(* ::Input:: *)
(*(*------------------------------------------------------ATTACCO BOOMERANG--------------------------------------------------------*)*)


(* ::Input:: *)
(*(*Funzioni usiliari: encryption parziale e decryption parziale*)*)
(*SerpentEncryptPartial[subkeys_List,blockWords_List,rmax_Integer]:=Module[{rounds},rounds=Table[With[{r=i},Function[b,SerpentRound[b,r,subkeys[[r+1]]]]],{i,0,rmax-1}];*)
(*Fold[#2[#1]&,blockWords,rounds]];*)
(**)
(*SerpentDecryptPartial[subkeys_List,blockWords_List,rmin_Integer]:=Fold[Function[{b,r},SerpentInvRound[b,r,subkeys[[r+1]]]],blockWords,Reverse@Range[0,rmin-1]];*)
(**)
(*NibbleDiff[a_List,b_List]:=MapThread[BitXor,{a,b}];*)
(**)
(**)
(**)
(*BoomerangSuccessQ[{Q_,Qp_},deltaIn_List]:=NibbleDiff[Q,Qp]===deltaIn ;*)
(**)
(**)
(**)


(* ::Input:: *)
(*SBoxDDT[sbox_List]:=Table[Count[Table[BitXor[sbox[[x+1]],sbox[[BitXor[x,dx]+1]]]==dy,{x,0,15}],True],{dx,0,15},{dy,0,15}];*)
(*DDTs=SBoxDDT/@SBoxes;*)
(*Manipulate[MatrixPlot[DDTs[[a]],ColorFunction->"ThermometerColors",FrameTicks->{Range[0,15],Range[0,15]},PlotLabel->"DDT S"<> ToString[a-1]],{a,1,8,1}]*)


(* ::Input:: *)
(*SboxBCT[S_List]:=Module[{n=Length[S],Sinv,bct},*)
(*Sinv=InversePermutation[S+1]-1;*)
(*bct=ConstantArray[0,{n,n}];*)
(*Do[*)
(*If[*)
(*BitXor[*)
(*Sinv[[BitXor[S[[x+1]],deltaOut]+1]],*)
(*Sinv[[BitXor[S[[BitXor[x,deltaIn]+1]],deltaOut]+1]]*)
(*]==deltaIn,*)
(*bct[[deltaIn+1,deltaOut+1]]++],*)
(*{deltaIn,0,n-1},{deltaOut,0,n-1},{x,0,n-1}];*)
(*bct];*)
(**)
(*BCTs=SboxBCT/@SBoxes;*)
(**)
(*Manipulate[MatrixPlot[BCTs[[a]],ColorFunction->"ThermometerColors",FrameTicks->{Range[0,15],Range[0,15]},PlotLabel->"BCT S"<> ToString[a-1]],{a,1,8,1}]*)


(* ::Input:: *)
(*(*pruning*)*)
(*PruneByLocalBCT[deltaX_List,deltaOut_List,word_,nib_,sboxIndex_]:=Module[{\[Delta]in,\[Delta]out},\[Delta]in=BitAnd[BitShiftRight[deltaX[[word]],4 nib],15];*)
(*\[Delta]out=BitAnd[BitShiftRight[deltaOut[[word]],4 nib],15];*)
(*\[Delta]in==0||BCTs[[sboxIndex,\[Delta]in+1,\[Delta]out+1]]>0];*)
(**)
(*PruneByActiveNibbles[delta_List,maxActive_]:=Length@ActiveNibbles[delta]<=maxActive;*)
(**)
(*LocalDelta[state_,delta_,word_,nib_]:=Module[{d=ConstantArray[0,4]},d[[word]]=BitShiftLeft[delta,4 nib];*)
(*NibbleDiff[state,d]];*)
(**)
(**)
(*BoomerangQuartet[subkeys_List,P_List,deltaIn_List,deltaOut_List,r0_Integer,r1_Integer,sboxIndex_Integer,word_Integer,nib_Integer]:=Module[{Pp,X,Xp,\[CapitalDelta]X,Y,Yp,Q,Qp},*)
(*Pp=NibbleDiff[P,deltaIn];*)
(*(*E\:2080*)*)
(*X=SerpentEncryptPartial[subkeys,P,r0];*)
(*Xp=SerpentEncryptPartial[subkeys,Pp,r0];*)
(*\[CapitalDelta]X=NibbleDiff[X,Xp];*)
(*(*pruning strutturale*)*)
(*If[!PruneByActiveNibbles[\[CapitalDelta]X,8],Return[False]];*)
(*(*pruning BCT localizzato*)*)
(*If[!PruneByLocalBCT[\[CapitalDelta]X,deltaOut,word,nib,sboxIndex],Return[False]];*)
(*(*boomerang switch*)*)
(*Y=LocalDelta[X,deltaOutNib,word,nib];*)
(*Yp=LocalDelta[Xp,deltaOutNib,word,nib];*)
(**)
(*(*E\:2081\:207b\.b9*)*)
(*Q=SerpentDecryptPartial[subkeys,Y,r1];*)
(*Qp=SerpentDecryptPartial[subkeys,Yp,r1];*)
(*{Q,Qp}];*)
(**)
(**)
(*BoomerangTrial[subkeys_,deltaIn_,deltaOut_,best_]:=Module[{P,QQ},P=RandomInteger[{0,2^32-1},4];*)
(*QQ=BoomerangQuartet[subkeys,P,deltaIn,deltaOut,3,3,4,best[[1]],best[[2]]];*)
(*If[QQ===False,False,BoomerangSuccessQ[QQ,deltaIn]]];*)
(*BoomerangExperiment[subkeys_,deltaIn_,deltaOut_,best_,Ntry_]:=Mean@Boole@Table[BoomerangTrial[subkeys,deltaIn,deltaOut,best],{Ntry}];*)
(**)
(**)


(* ::Input:: *)
(*(*S3 perch\[EGrave] e\[EGrave] il nostro round di boomerang *)*)
(*B=BCTs[[4]];*)
(*(*estraiamo le coppie (deltaIn,deltaOut) valide*)*)
(*ValidPairs=Select[Flatten[Table[{dx,dy,B[[dx+1,dy+1]]},{dx,1,15},{dy,1,15}],1],#[[3]]>0&];*)
(*Pairs=SortBy[ValidPairs,-#[[3]]&][[;;10]]*)
(**)
(**)


(* ::Input:: *)
(*(*----- studio propagazione dei delta -------*)*)
(*(*resituisce posizioni dei nibble attivi*)*)
(*ActiveNibbles[state_List]:=Module[{nibs},*)
(*nibs=Flatten@Table[BitAnd[BitShiftRight[state[[w]],4*n],15],{w,1,4},{n,0,7}];*)
(*Position[nibs,_?(#!=0&)]];*)
(**)
(*(*innestiamo un solo nibble attivo*)*)
(*EmbedNibbleDelta[delta_,wordPos_,nibblePos_]:=Module[{state=ConstantArray[0,4]},*)
(*state[[wordPos]]=BitShiftLeft[delta,4*nibblePos];*)
(*state];*)
(**)
(* PropagateDeltaRounds[subkeys_,delta_,r_]:=NestList[SerpentEncryptPartial[subkeys,#,1]&,delta,r];*)
(**)
(*delta0=EmbedNibbleDelta[1,1,0];*)
(**)
(*key="00112233445566778899AABBCCDDEEFF";*)
(*subkeys=SerpentKeySchedule[key];*)
(**)
(*trail=PropagateDeltaRounds[subkeys,delta0,3];*)
(*Table[ActiveNibbles[trail[[i]]],{i,1,Length[trail]}]*)
(**)
(*ScanDeltas:=Table[{w,n,Length@ActiveNibbles[Last@PropagateDeltaRounds[subkeys,EmbedNibbleDelta[1,w,n],3]]},{w,1,4},{n,0,7}]//Flatten[#,1]&;*)
(*(*{word,nibble,#SboxAttiveAlRound3}*)*)
(*SortBy[ScanDeltas,Last]*)
(**)
(**)
(**)


(* ::Input:: *)
(**)
(**)
(**)
(**)
(*best=First@SortBy[ScanDeltas,Last];*)
(**)
(*deltaIn=EmbedNibbleDelta[13,best[[1]],best[[2]]];*)
(*deltaOut=EmbedNibbleDelta[4,best[[1]],best[[2]]];*)
(*deltaOutNib=4;*)
(**)
(*BoomerangExperiment[subkeys,deltaIn,deltaOut,best,20000]*)
(**)
(**)
(**)
(**)
(**)
(**)
(**)
